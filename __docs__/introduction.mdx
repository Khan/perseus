import {Markdown, Meta} from "@storybook/addon-docs/blocks";

<Meta
    title="Introduction"
    parameters={{docs: {toc: {headingSelector: "h2, h3"}}}}
/>

# Perseus

Perseus is the technology that powers all exercises and articles at Khan Academy. Since 2013, it has been a core part of
Khan Academy's educational platform, existing both as an integrated component of the Khan Academy applications (web and mobile)
and as a separate open-source repository.

## What is Perseus?

At its core, Perseus is a specialized Markdown to React/HTML renderer with powerful educational features. It extends
standard Markdown with two key capabilities:

**1. Interactive Widgets,** Perseus can render custom React components called "widgets" that allow learners to interact with content and provide answers in various formats.

**2. Beautiful Math Rendering,** Perseus seamlessly integrates with [MathJax](https://www.mathjax.org/) to display mathematical expressions and equations with high fidelity.

These capabilities make Perseus ideal for creating interactive educational content that combines explanatory text, rich media, and assessment tools.

## How Perseus Works

Perseus content is written in an extended Markdown syntax that includes:

-   Standard Markdown formatting (headings, lists, links, etc.)
-   Math expressions enclosed in dollar signs: `$y = mx + b$`
-   Widgets using the syntax: `[[☃ widget-type 1]]`, where each widget has a unique ID

When a learner interacts with widgets (such as answering questions), Perseus can:

-   Validate answers against expected solutions
-   Provide feedback and hints
-   Support a variety of input methods

## Core Components

Perseus consists of three main concepts:

### 1. Renderers

Renderers are responsible for displaying Perseus content. The three primary renderers are:

-   **ServerItemRenderer**: The main exercise renderer that handles question content, hint management, and keypad display
-   **ArticleRenderer**: Renders long-form, read-only content, with support for embedded "knowledge checks"
-   **Renderer**: The core rendering engine that manages widgets and math content display

For more detailed information on renderers, refer to the [Perseus Renderers Overview](?path=/docs/renderers-overview--docs).

### 2. Widgets

Widgets are self-contained React components that provide interactive functionality beyond standard Markdown. They can:

-   Appear within articles and exercises (in questions and hints)
-   Be nested within other widgets (e.g., the "graded-group" widget)
-   Handle various input types (multiple-choice, graphing, numeric input, etc.)
-   Validate and score user responses

### 3. Editors

Editors provide the interface for content creators to:

-   Add/Edit Perseus content
-   Configure widget settings
-   Preview content as it will appear to learners

Each widget type has its own specialized editor component.

## Data Flow

Perseus is in charge of creating, parsing, rendering, and scoring exercises. Perseus strives for modularity, allowing consumers to define how and when things happen.

A high-level overview:

-   Content - JSON containing Markdown - is created using widget editors
-   We parse and migrate the data before using it
-   The renderers take the data and render a UI
-   We use the data and the user input to generate a score

### A More Detailed Look at Data Flow at Khan Academy

Perseus defines around 30 types of "widgets" for content that can't be represented by vanilla Markdown. Widgets are used e.g. for the interactive parts of exercises. Widgets get embedded into Markdown documents via a "snowman placeholder" like [[☃ radio 1]].

As much as possible, we decouple widget logic from shared logic:

-   The editors defer to individual widget editors for creating widget options
-   `splitPerseusItem` defers to individual widget splitting functions
-   `parseAndMigratePerseusItem` defers to individual widget parsing functions
-   The renderers defer to individual widget components for rendering/updating
-   `validateUserInput` defers to individual widget validators
-   `scorePerseusItem` defers to individual widget scorers

#### Generating Content

`@khanacademy/perseus-editor`

-   We have two main editing pages:
    -   `ArticleEditor` for editing articles
    -   `EditorPage` for editing exercises
-   The editing pages take the output from the widget editors to make a full piece of content
    -   `PerseusArticle` for articles
    -   `PerseusItem` for exercises
-   The content is stringified and sent to the content pipeline
-   The content pipeline parses content to find translatable strings

Additionally for exercises, we generate an "answerless" version of the PerseusItem. This is sent to the learner pre-attempt to prevent cheating.

#### Parsing Content

`@khanacademy/perseus-core`

Over time the shape of our data changes, so we migrate old versions of the data to new versions.

-   We have parsers:
    -   `parseAndMigratePerseusArticle` for articles
    -   `parseAndMigratePerseusItem` for exercises
-   They parse the stringified data into a valid object
-   They migrate old formats of the content to the latest version

#### Rendering Content

`@khanacademy/perseus`

-   We have multiple renderers:
    -   `ArticleRenderer` for articles
    -   `ServerItemRenderer` for exercises
-   They take data and render a UI using React
-   The UI is configurable (see `PerseusDependencies` and `ApiOptions`)

#### Scoring User Input

`@khanacademy/perseus-score`

Widgets in articles are scored internally and scores are not recorded (see `GradedGroup` and `GradedGroupSet`).

Scoring exercises is a little more complex:

-   `ServerItemRenderer` provides `getUserInput` for getting the user input
-   We do client-side validation using `validateUserInput`
    -   We do as much validation as possible with the "answerless" `PerseusItem`
-   We make a call to the Perseus Service (a Node server) for scoring
    -   We provide the `UserInput`
    -   We provide the "answerful" `PerseusItem`
-   We call `scorePerseusItem`
    -   It does server-side validation (validation requiring "answerful" data)
    -   It scores each widgets
    -   It returns a final score (correct/incorrect/invalid)

We return the "answerful" `PerseusItem` with the attempt and the UI updates to show answer, hints, and rationales.

## TypeScript Types and Conventions

Perseus uses a consistent set of types to define its data structures and components. Understanding these types is crucial for working with Perseus code effectively.

### Data Types

<Markdown>
    {`
| Type | Description |
| ---- | ----------- |
| \`PerseusItem\` | Top-level structure that the \`ServerItemRenderer\` accepts. You can think of the \`PerseusItem\` type as the "data schema" for Perseus exercise questions. |
| \`PerseusArticle\` | Is just a series of \`PerseusRenderer\` objects. It can be a single object, but most often it is an array of them. These are never scored. |
| \`PerseusRenderer\` | Core structure used by Perseus. It is rendered by the \`Renderer\` component and is used through Perseus to render content (even within widgets). |
| \`WidgetExports\<T\>\` | The type defines a widget. This structure defines which React component implements the widget as well as any required data transforms and metadata. You can look up these exports by using the \`getWidgetExport(widgetType)\` function from \`widgets.ts\`. |
| \`WidgetOptions\<T\>\` | All widget options are contained within a common \"header\" object that is represented by \`WidgetOptions\<T\>\`. The \`T\` generic type in this case is the widget type name (e.g., \`dropdown\`, \`interactive-graph\`, etc.). This type contains an \`options\` key which then contains the options specific to the widget. Each widget defines its set of options through an options type (always defined in \`perseus-types.ts\`. These can be thought of as the "schema" for the widget. |
    `}
</Markdown>

### Widget Options

Each widget defines its set of options through an options type (always defined in `perseus-types.ts`. These can be thought of as the "schema" for the widget.

### React Types

Each widget is implemented as a React component. As is common with React, the component receives data via render props.
The code strives to use the following conventions to shape the various concepts of props.

<Markdown>
    {`
| Type | Description |
| ---- | ----------- |
| \`WidgetProps\<T\>\` | All widgets receive a common set of props from the parent \`Renderer\` component This set of props is defined by the \`WidgetProps\<T\>\` type (\`T\` being the specific render props the widget uses). |
| External Props | In a few rare cases, this type is defined as the sum of specific WidgetOptions wrapped in the shared \`WidgetOptions\`. |
| Scoring Data | This type defines the data that the scoring function needs in order to score the learner's guess (aka user input). |
| \`Props\` | This form the entire set of props that widget's component supports. Typically, it is defined as \`type Props = WidgetProps<WidgetOptions, Rubric>\`. In cases where there are \`WidgetOptions\` that are optional that are provided via \`DefaultProps\`, this \`Props\` type "redefines" these props as \`myProp: NonNullable<ExternalProps["myProps"]>;\`. |
    `}
</Markdown>

## Content Editing

The Perseus content editing flow follows these steps:

**1. The editor renders an `EditorPage` component**

**2. As content is edited, `onChange` callbacks are triggered**

**3. When serialization is needed, `editorPageRef.current.serialize()` is called to produce a `PerseusItem`**

This editing flow ensures that content creators can interact with widgets and preview content as it will appear to learners.

## Getting Started

The best way to understand Perseus is to explore the components in this Storybook. You can:

-   Browse the Widget Gallery to see the available widgets
-   Read the renderer documentation
-   Browse the available reusable components
