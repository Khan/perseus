#!/usr/bin/env -S node -r @swc-node/register
/**
 * Extracts i18n strings from each package and writes them out to <package>/dist/strings.js.
 *
 * This file contains i18n._(), i18n._$(), and i18n.ngettext() calls that can be re-extracted
 * by webapp.  This is required for so that we can leverage webapp's translation pipeline
 * which is responsible for uploading strings to Crowdin.
 *
 * Usage:
 * node /utils/extract-strings.js
 */

import fs from "fs";
import path from "path";

import {extractStrings} from "@khanacademy/wonder-stuff-i18n";
import ancesdir from "ancesdir";
import fg from "fast-glob";

import {getLogger} from "./internal/logger";

const rootDir = ancesdir(__dirname);

const logger = getLogger();

type I18nString = {
    type: string;
    msgids: Array<string>;
    comments: Array<string>;
};

const generateStringsFileForPackage = (pkgName) => {
    const glob = path.join(
        rootDir,
        "packages",
        pkgName,
        "src",
        "**",
        "*.{ts,tsx}",
    );
    const files = fg.sync(glob);

    files.sort();

    let strings: Array<I18nString> = [];

    for (const file of files) {
        logger.debug(`processing ${file}`);
        const content = fs.readFileSync(file, "utf-8");
        const extracted = extractStrings(content);
        // NOTE(kevinb): We use for-of here instead of doing
        // strings.push(...extracted) because our babel config
        // has its @babel/plugin-transform-spread plugin using
        // loose: true and `extracted` is not an array (it's a
        // a generator).
        for (const string of extracted) {
            strings.push(string);
            logger.debug(`extracted string: ${JSON.stringify(string)}`);
        }
    }

    const memoMap = new Map();

    strings = strings.filter((string) => {
        if (memoMap.has(string.msgids[0])) {
            // Copy over any comments to the memoized instance.
            const memoedString = memoMap.get(string.msgids[0]);
            if (memoedString) {
                memoedString.comments.push(...string.comments);
            }
            return false;
        }
        memoMap.set(string.msgids[0], string);
        return true;
    });

    strings.sort((a, b) => a.msgids[0].localeCompare(b.msgids[0]));
    if (strings.length === 0) {
        logger.info(`No translateable strings in ${pkgName}`);
        return;
    }

    const outDir = path.join(rootDir, "packages", pkgName, "dist");
    if (!fs.existsSync(outDir)) {
        fs.mkdirSync(outDir, {recursive: true});
    }

    const outPath = path.join(outDir, "strings.js");
    const fd = fs.openSync(outPath, "w");

    const writeLine = (line) => fs.writeSync(fd, line + "\n");

    const header = `// @noflow
 /**
  * WARNING: This is an autogenerated file.  Do not edit by hand.
  * To regenerate, run: yarn extract-strings.
  */
 `;

    writeLine(header);
    writeLine("module.exports = [");
    for (const string of strings) {
        if (string.comments) {
            for (const comment of string.comments) {
                writeLine(`    // I18N: ${comment}`);
            }
        }
        const args = string.msgids
            .map((msgid) => JSON.stringify(msgid))
            .join(",");
        writeLine(`    i18n.${string.type}(${args}, {}),`);
    }
    writeLine("];");
    fs.closeSync(fd);
    logger.info(
        `wrote ${strings.length} strings to ${path.relative(rootDir, outPath)}`,
    );
};

if (require.main === module) {
    fs.readdirSync(path.join(rootDir, "packages"))
        .filter((name) => {
            const stat = fs.statSync(path.join(rootDir, "packages", name));
            return stat.isDirectory();
        })
        .map(generateStringsFileForPackage);
}
