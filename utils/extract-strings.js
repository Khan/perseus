#!/usr/bin/env ./node_modules/.bin/babel-node
// @flow
/**
 * Extracts i18n strings from:
 * - perseus-all-package
 * - perseus-merged-extra-widgets-package
 * - perseus-merged-editor-package
 * - node_modules/math-input
 * and write them to javascript/perseus/perseus.strings.js as i18n.*() calls so
 * that they can be processed by our nightly translation job which uploads strings
 * to Crowdin.
 *
 * Notes:
 * - This script must be run from services/static/ since the shebang makes use of
 *   a relative path.
 */
import fs from "fs";
import path from "path";
import ancesdir from "ancesdir";
import fg from "fast-glob";
import {extractStrings} from "@khanacademy/wonder-stuff-i18n";

import {getLogger} from "./internal/logger.js";

const rootDir = ancesdir(__dirname);

const logger = getLogger();

export const generateStringsFile = (filename: string) => {
    const packages = ["perseus", "perseus-editor"];

    const glob = path.join(
        rootDir,
        "packages",
        packages.length > 1 ? `{${packages.join(",")}}` : packages[0],
        "**",
        "*.{js,jsx}",
    );
    const files = fg.sync(glob);
    files.push(
        // NOTE(kevinb): Extracting strings from build files is not ideal since we
        // lose any I18N comments.  Once Perseus is in its own repo we should move
        // math-input there as well so that we can run string extraction on the source.
        path.join(
            rootDir,
            "node_modules",
            "@khanacademy",
            "math-input",
            "build",
            "math-input.js",
        ),
    );
    files.sort();

    let strings = [];

    for (const file of files) {
        logger.debug(`processing ${file}`);
        const content = fs.readFileSync(file, "utf-8");
        const extracted = extractStrings(content);
        // NOTE(kevinb): We use for-of here instead of doing
        // strings.push(...extracted) because our babel config
        // has its @babel/plugin-transform-spread plugin using
        // loose: true and `extracted` is not an array (it's a
        // a generator).
        for (const string of extracted) {
            strings.push(string);
            logger.debug(`extracted string: ${JSON.stringify(string)}`);
        }
    }

    const memoMap = new Map();

    strings = strings.filter((string) => {
        if (memoMap.has(string.msgids[0])) {
            // Copy over any comments to the memoized instance.
            const memoedString = memoMap.get(string.msgids[0]);
            if (memoedString) {
                memoedString.comments.push(...string.comments);
            }
            return false;
        }
        memoMap.set(string.msgids[0], string);
        return true;
    });

    strings.sort((a, b) => a.msgids[0].localeCompare(b.msgids[0]));

    const outDir = path.join(rootDir, "dist");
    if (!fs.existsSync(outDir)) {
        fs.mkdirSync(outDir, {recursive: true});
    }

    const outPath = filename.startsWith("/")
        ? filename
        : path.join(outDir, filename);

    const fd = fs.openSync(outPath, "w");

    const writeLine = (line) => fs.writeSync(fd, line + "\n");

    const header = `// @noflow
 /**
  * WARNING: This is an autogenerated file.  Do not edit by hand.
  * To regenerate, run: strings.js.
  */
 `;

    writeLine(header);
    writeLine("module.exports = [");
    for (const string of strings) {
        if (string.comments) {
            for (const comment of string.comments) {
                writeLine(`    // I18N: ${comment}`);
            }
        }
        const args = string.msgids
            .map((msgid) => JSON.stringify(msgid))
            .join(",");
        writeLine(`    i18n.${string.type}(${args}, {}),`);
    }
    writeLine("];");
    fs.closeSync(fd);
    logger.info(`wrote ${strings.length} strings to ${outPath}`);
};

if (require.main === module) {
    generateStringsFile("strings.js");
}
