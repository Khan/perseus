<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>KAS Browser Tests</title>

    <!-- Include QUnit -->
    <link rel="stylesheet" href="node_modules/qunit/qunit/qunit.css" type="text/css" media="screen">
    <script src="node_modules/qunit/qunit/qunit.js"></script>
    <script src="node_modules/qunit-assert-close/qunit-assert-close.js"></script>

    <!-- Include Underscore -->
    <script src="node_modules/underscore/underscore.js"></script>

    <!-- Include KAS -->
    <script src="src/parser.js"></script>
    <script src="src/unitparser.js"></script>
    <script src="src/nodes.js"></script>
    <script src="src/compare.js"></script>
</head>
<body>

<h1 id="qunit-header">KAS Browser Tests</h1>
<h2 id="qunit-banner"></h2>
<div id="qunit-testrunner-toolbar"></div>
<h2 id="qunit-userAgent"></h2>
<ol id="qunit-tests"></ol>

<div id="qunit-fixture">
    <div id="solutionarea">
    </div>
    <div class="problem">
    </div>
</div>

<script type="text/javascript">
(function(KAS) {

    var parse = function(input, options) {
        return KAS.parse(input, options).expr;
    };


    QUnit.module("parsing");

    var print = function(assert, input, expected, options) {
        var message = input + " parses as " + expected;
        assert.close(parse(input, options).print(), expected, 1e-9, message);
    };

    QUnit.test("empty", function(assert) {
        print(assert, "", "");
    });

    QUnit.test("positive and negative primitives", function(assert) {
        print(assert, "0", "0");
        print(assert, "1.", "1");
        print(assert, "3.14", "3.14");
        print(assert, ".14", "0.14");
        print(assert, "pi", "pi");
        print(assert, "e", "e");
        print(assert, "x", "x");
        print(assert, "theta", "theta");

        print(assert, "-0", "-1*0");
        print(assert, "-1.", "-1");
        print(assert, "-3.14", "-3.14");
        print(assert, "-.14", "-0.14");
        print(assert, "-pi", "-1*pi");
        print(assert, "-e", "-1*e");
        print(assert, "-theta", "-1*theta");
    });

    QUnit.test("LaTeX constants", function(assert) {
        print(assert, "\\theta", "theta");
        print(assert, "\\pi", "pi");
        print(assert, "\\phi", "phi");
    });

    QUnit.test("ignore TeX spaces", function(assert) {
        print(assert, "a\\space b", "a*b");
        print(assert, "a\\ b", "a*b");
    });

    QUnit.test("positive and negative rationals", function(assert) {
        print(assert, "1/2", "1/2");
        print(assert, "-1/2", "-1/2");
        print(assert, "1/-2", "-1/2");
        print(assert, "-1/-2", "-1*-1/2");
        print(assert, "42/42", "42/42");
        print(assert, "42/1", "42/1");
        print(assert, "0/42", "0/42");

        print(assert, "2 (1/2)", "2*1/2");
        print(assert, "1/2 1/2", "1/2*1/2");
        print(assert, "-1/2", "-1/2");
        print(assert, "1/2 2", "1/2*2");
    });

    QUnit.test("rationals using \\frac", function(assert) {
        print(assert, "\\frac{1}{2}", "1/2");
        print(assert, "\\frac{-1}{2}", "-1/2");
        print(assert, "\\frac{1}{-2}", "-1/2");
        print(assert, "\\frac{-1}{-2}", "-1*-1/2");
        print(assert, "\\frac{42}{42}", "42/42");
        print(assert, "\\frac{42}{1}", "42/1");
        print(assert, "\\frac{0}{42}", "0/42");

        print(assert, "2\\frac{1}{2}", "2*1/2");
        print(assert, "\\frac{1}{2}\\frac{1}{2}", "1/2*1/2");
        print(assert, "-\\frac{1}{2}", "-1/2");
        print(assert, "\\frac{1}{2}2", "1/2*2");
    });

    QUnit.test("rationals using \\dfrac", function(assert) {
        print(assert, "\\dfrac{1}{2}", "1/2");
        print(assert, "\\dfrac{-1}{2}", "-1/2");
        print(assert, "\\dfrac{1}{-2}", "-1/2");
        print(assert, "\\dfrac{-1}{-2}", "-1*-1/2");
        print(assert, "\\dfrac{42}{42}", "42/42");
        print(assert, "\\dfrac{42}{1}", "42/1");
        print(assert, "\\dfrac{0}{42}", "0/42");

        print(assert, "2\\dfrac{1}{2}", "2*1/2");
        print(assert, "\\dfrac{1}{2}\\dfrac{1}{2}", "1/2*1/2");
        print(assert, "-\\dfrac{1}{2}", "-1/2");
        print(assert, "\\dfrac{1}{2}2", "1/2*2");
    });

    QUnit.test("parens", function(assert) {
        print(assert, "(0)", "0");
        print(assert, "(ab)", "a*b");
        print(assert, "(a/b)", "a*b^(-1)");
        print(assert, "(a^b)", "a^(b)");
        print(assert, "(ab)c", "a*b*c");
        print(assert, "a(bc)", "a*b*c");
        print(assert, "a+(b+c)", "a+b+c");
        print(assert, "(a+b)+c", "a+b+c");
        print(assert, "a(b+c)", "a*(b+c)");
        print(assert, "(a+b)^c", "(a+b)^(c)");
        print(assert, "(ab)^c", "(a*b)^(c)");
    });

    QUnit.test("subscripts", function(assert) {
        print(assert, "a", "a");
        print(assert, "a_0", "a_(0)");
        print(assert, "a_i", "a_(i)");
        print(assert, "a_n", "a_(n)");
        print(assert, "a_n+1", "a_(n)+1");
        print(assert, "a_(n+1)", "a_(n+1)");
        print(assert, "a_{n+1}", "a_(n+1)");
    });

    QUnit.test("negation", function(assert) {
        print(assert, "-x", "-1*x");
        print(assert, "--x", "-1*-1*x");
        print(assert, "---x", "-1*-1*-1*x");
        print(assert, "-1", "-1");
        print(assert, "--1", "-1*-1");
        print(assert, "---1", "-1*-1*-1");
        print(assert, "-3x", "-3*x");
        print(assert, "--3x", "-1*-3*x");
        print(assert, "-x*3", "x*-3");
        print(assert, "--x*3", "-1*x*-3");
        print(assert, "\u2212x", "-1*x");
    });

    QUnit.test("addition and subtraction", function(assert) {
        print(assert, "a+b", "a+b");
        print(assert, "a-b", "a+-1*b");
        print(assert, "a--b", "a+-1*-1*b");
        print(assert, "a---b", "a+-1*-1*-1*b");
        print(assert, "2-4", "2+-4");
        print(assert, "2--4", "2+-1*-4");
        print(assert, "2---4", "2+-1*-1*-4");
        print(assert, "2-x*4", "2+x*-4");
        print(assert, "1-2+a-b+pi-e", "1+-2+a+-1*b+pi+-1*e");
        print(assert, "x+1", "x+1");
        print(assert, "x-1", "x+-1");
        print(assert, "(x-1)", "x+-1");
        print(assert, "a(x-1)", "a*(x+-1)");
        print(assert, "a\u2212b", "a+-1*b");
    });

    QUnit.test("multiplication", function(assert) {
        print(assert, "a*b", "a*b");
        print(assert, "-a*b", "-1*a*b");
        print(assert, "a*-b", "a*-1*b");
        print(assert, "-ab", "-1*a*b");
        print(assert, "-a*b", "-1*a*b");
        print(assert, "-(ab)", "-1*a*b");
        print(assert, "a\u00b7b", "a*b");
        print(assert, "a\u00d7b", "a*b");
        print(assert, "a\\cdotb", "a*b");
        print(assert, "a\\timesb", "a*b");
        print(assert, "a\\astb", "a*b");
    })

    QUnit.test("division", function(assert) {
        print(assert, "a/b", "a*b^(-1)");
        print(assert, "a/bc", "a*b^(-1)*c");
        print(assert, "(ab)/c", "a*b*c^(-1)");
        print(assert, "ab/c", "a*b*c^(-1)");
        print(assert, "ab/cd", "a*b*c^(-1)*d");
        print(assert, "a\\divb", "a*b^(-1)");
        print(assert, "a\u00F7b", "a*b^(-1)");
    });

    QUnit.test("exponentiation", function(assert) {
        print(assert, "x^y", "x^(y)");
        print(assert, "x^y^z", "x^(y^(z))");
        print(assert, "x^yz", "x^(y)*z");
        print(assert, "-x^2", "-1*x^(2)");
        print(assert, "-(x^2)", "-1*x^(2)");
        print(assert, "0-x^2", "0+-1*x^(2)");
        print(assert, "x^-y", "x^(-1*y)");
        print(assert, "x^(-y)", "x^(-1*y)");
        print(assert, "x^-(y)", "x^(-1*y)");
        print(assert, "x^-(-y)", "x^(-1*-1*y)");
        print(assert, "x^--y", "x^(-1*-1*y)");
        print(assert, "x^-yz", "x^(-1*y)*z");
        print(assert, "x^-y^z", "x^(-1*y^(z))");
        print(assert, "x**y", "x^(y)");

        print(assert, "x^{a}", "x^(a)");
        print(assert, "x^{ab}", "x^(a*b)");
    });

    QUnit.test("square root", function(assert) {
        print(assert, "sqrt(x)", "x^(1/2)");
        print(assert, "sqrt(x)y", "x^(1/2)*y");
        print(assert, "1/sqrt(x)", "x^(-1/2)");
        print(assert, "1/sqrt(x)y", "x^(-1/2)*y");

        print(assert, "sqrt(2)/2", "2^(1/2)*1/2");
        print(assert, "sqrt(2)^2", "(2^(1/2))^(2)");

        print(assert, "\\sqrt(x)", "x^(1/2)");
        print(assert, "\\sqrt(x)y", "x^(1/2)*y");
        print(assert, "1/\\sqrt(x)", "x^(-1/2)");
        print(assert, "1/\\sqrt(x)y", "x^(-1/2)*y");

        print(assert, "\\sqrt(2)/2", "2^(1/2)*1/2");
        print(assert, "\\sqrt(2)^2", "(2^(1/2))^(2)");

        print(assert, "\\sqrt{2}", "2^(1/2)");
        print(assert, "\\sqrt{2+2}", "(2+2)^(1/2)");
    });

    QUnit.test("nth root", function(assert) {
        print(assert, "sqrt[3]{x}", "x^(1/3)");
        print(assert, "sqrt[4]{x}y", "x^(1/4)*y");
        print(assert, "1/sqrt[5]{x}", "x^(-1/5)");
        print(assert, "1/sqrt[7]{x}y", "x^(-1/7)*y");

        print(assert, "sqrt[3]{2}/2", "2^(1/3)*1/2");
        print(assert, "sqrt[3]{2}^2", "(2^(1/3))^(2)");

        print(assert, "\\sqrt[4]{x}", "x^(1/4)");
        print(assert, "\\sqrt[4]{x}y", "x^(1/4)*y");
        print(assert, "1/\\sqrt[4]{x}", "x^(-1/4)");
        print(assert, "1/\\sqrt[4]{x}y", "x^(-1/4)*y");

        print(assert, "\\sqrt[5]{2}/2", "2^(1/5)*1/2");
        print(assert, "\\sqrt[5]{2}^2", "(2^(1/5))^(2)");

        print(assert, "\\sqrt[6]{2}", "2^(1/6)");
        print(assert, "\\sqrt[6]{2+2}", "(2+2)^(1/6)");

        print(assert, "\\sqrt[2]{2}", "2^(1/2)");
        print(assert, "\\sqrt[2]{2+2}", "(2+2)^(1/2)");
    });

    QUnit.test("absolute value", function(assert) {
        print(assert, "abs(x)", "abs(x)");
        print(assert, "abs(abs(x))", "abs(abs(x))");
        print(assert, "abs(x)abs(y)", "abs(x)*abs(y)");

        print(assert, "|x|", "abs(x)");
        print(assert, "||x||", "abs(abs(x))");
        // TODO(alex): fix the below so it doesn't require an *
        // may require own lexer/preprocessor
        print(assert, "|x|*|y|", "abs(x)*abs(y)");

        print(assert, "\\abs(x)", "abs(x)");
        print(assert, "\\abs(\\abs(x))", "abs(abs(x))");
        print(assert, "\\abs(x)\\abs(y)", "abs(x)*abs(y)");

        print(assert, "\\left|x\\right|", "abs(x)");
        print(assert, "\\left|\\left|x\\right|\\right|", "abs(abs(x))");
        print(assert, "\\left|x\\right|\\left|y\\right|", "abs(x)*abs(y)");
    });

    QUnit.test("logarithms", function(assert) {
        print(assert, "lnx", "ln(x)");
        print(assert, "ln x", "ln(x)");
        print(assert, "ln x^y", "ln(x^(y))");
        print(assert, "ln xy", "ln(x*y)");
        print(assert, "ln x/y", "ln(x*y^(-1))");
        print(assert, "ln x+y", "ln(x)+y");
        print(assert, "ln x-y", "ln(x)+-1*y");

        print(assert, "ln xyz", "ln(x*y*z)");
        print(assert, "ln xy/z", "ln(x*y*z^(-1))");
        print(assert, "ln xy/z+1", "ln(x*y*z^(-1))+1");

        print(assert, "ln x(y)", "ln(x)*y");

        print(assert, "logx", "log_(10) (x)");
        print(assert, "log x", "log_(10) (x)");
        print(assert, "log_2x", "log_(2) (x)");
        print(assert, "log _ 2 x", "log_(2) (x)");
        print(assert, "log_bx_0", "log_(b) (x_(0))");
        print(assert, "log_x_0b", "log_(x_(0)) (b)");

        print(assert, "log_2.5x", "log_(2.5) (x)");

        print(assert, "ln ln x", "ln(ln(x))");
        print(assert, "ln x ln y", "ln(x)*ln(y)");
        print(assert, "ln x/ln y", "ln(x)*ln(y)^(-1)");

        print(assert, "\\lnx", "ln(x)");
        print(assert, "\\ln x", "ln(x)");
        print(assert, "\\ln x^y", "ln(x^(y))");
        print(assert, "\\ln xy", "ln(x*y)");
        print(assert, "\\ln x/y", "ln(x*y^(-1))");
        print(assert, "\\ln x+y", "ln(x)+y");
        print(assert, "\\ln x-y", "ln(x)+-1*y");

        print(assert, "\\logx", "log_(10) (x)");
        print(assert, "\\log x", "log_(10) (x)");
        print(assert, "\\log_2x", "log_(2) (x)");
        print(assert, "\\log _ 2 x", "log_(2) (x)");
        print(assert, "\\log_bx_0", "log_(b) (x_(0))");
        print(assert, "\\log_x_0b", "log_(x_(0)) (b)");

        print(assert, "\\log_2.5x", "log_(2.5) (x)");

        print(assert, "\\frac{\\logx}{y}", "log_(10) (x)*y^(-1)");
        print(assert, "\\frac{\\log x}{y}", "log_(10) (x)*y^(-1)");
    });

    QUnit.test("trig functions", function(assert) {
        var functions = [
            "sin", "cos", "tan",
            "csc", "sec", "cot"
        ];

        var inverses = _.map(functions, function(func) {
            return "arc" + func;
        });

        _.each(functions.concat(inverses), function(func) {
            print(assert, func + "x", func + "(x)");
            print(assert, "\\" + func + "x", func + "(x)");
        });

        print(assert, "sin^-1 x", "arcsin(x)");
        print(assert, "\\sin^-1 x", "arcsin(x)");

        print(assert, "(sinx)^2", "sin(x)^(2)");
        print(assert, "sin^2x", "sin(x)^(2)");
        print(assert, "sin^2(x)", "sin(x)^(2)");
        print(assert, "sin^2 x", "sin(x)^(2)");
        print(assert, "(sin^2x)", "sin(x)^(2)");

        print(assert, "sin xy", "sin(x*y)");
        print(assert, "sin x(y)", "sin(x)*y");
        print(assert, "sin x/y", "sin(x*y^(-1))");
        print(assert, "(sin x)/y", "sin(x)*y^(-1)");

        print(assert, "sin sin x", "sin(sin(x))");
        print(assert, "sin x sin y", "sin(x)*sin(y)");
        print(assert, "sin x/sin y", "sin(x)*sin(y)^(-1)");

        print(assert, "1/(sinx)^2", "sin(x)^(-2)");
        print(assert, "1/sin^2x", "sin(x)^(-2)");
        print(assert, "1/sin^2(x)", "sin(x)^(-2)");
        print(assert, "1/(sin^2x)", "sin(x)^(-2)");

        print(assert, "sin(theta)", "sin(theta)");
        print(assert, "\\sin(\\theta)", "sin(theta)");
    });

    QUnit.test("hyperbolic functions", function(assert) {
        print(assert, "sinh xy", "sinh(x*y)");
        print(assert, "1/(sinhx)^2", "sinh(x)^(-2)");
        print(assert, "\\sinh(\\theta)", "sinh(theta)");
    });

    QUnit.test("formulas", function(assert) {
        print(assert, "mx+b", "m*x+b");
        print(assert, "v^2/r", "v^(2)*r^(-1)");
        print(assert, "4/3pir^3", "4/3*pi*r^(3)");
        print(assert, "4/3\u03C0r^3", "4/3*pi*r^(3)");
        print(assert, "sin^2 x + cos^2 x = 1", "sin(x)^(2)+cos(x)^(2)=1");
    });

    QUnit.test("factors", function(assert) {
        print(assert, "(6x+1)(x-1)", "(6*x+1)*(x+-1)");
    });

    QUnit.test("whitespace", function(assert) {
        print(assert, "12/3", "12/3");
        print(assert, "12 /3", "12/3");
        print(assert, "12/ 3", "12/3");
        print(assert, "xy", "x*y");
        print(assert, "x y", "x*y");
    });

    QUnit.test("equations", function(assert) {
        print(assert, "y=x", "y=x");
        print(assert, "y=x^2", "y=x^(2)");
        print(assert, "1<2", "1<2");
        print(assert, "1<=2", "1<=2");
        print(assert, "1\\le2", "1<=2");
        print(assert, "2>1", "2>1");
        print(assert, "2>=1", "2>=1");
        print(assert, "2\\ge1", "2>=1");
        print(assert, "1<>2", "1<>2");
        print(assert, "1=/=2", "1<>2");
        print(assert, "1\\ne2", "1<>2");
        print(assert, "1\\neq2", "1<>2");
        print(assert, "a\u2260b", "a<>b");
        print(assert, "a\u2264b", "a<=b");
        print(assert, "a\u2265b", "a>=b");
    });

    QUnit.test("function variables", function(assert) {
        print(assert, "f(x)", "f*x");
        print(assert, "f(x)", "f(x)", {functions: ["f"]});
        print(assert, "f(x+y)", "f(x+y)", {functions: ["f"]});
        print(assert, "f(x)g(x)", "f(x)*g(x)", {functions: ["f", "g"]});
        print(assert, "f(g(h(x)))", "f(g(h(x)))", {functions: ["f", "g", "h"]});

        print(assert, "f\\left(x\\right)", "f*x");
        print(assert, "f\\left(x\\right)", "f(x)", {functions: ["f"]});
        print(assert, "f\\left(x+y\\right)", "f(x+y)", {functions: ["f"]});
        print(assert, "f\\left(x\\right)g\\left(x\\right)", "f(x)*g(x)", {functions: ["f", "g"]});
        print(assert, "f\\left(g\\left(h\\left(x\\right)\\right)\\right)", "f(g(h(x)))", {functions: ["f", "g", "h"]});
    });

    var repr = function(assert, input, expected, options) {
        var message = input + " parses as " + expected;
        assert.strictEqual(parse(input, options).repr(), expected, message);
    };

    QUnit.test("structure", function(assert) {
        repr(assert, "", "Add()");
        repr(assert, "1.", "1");
        repr(assert, "1/2", "1/2");
        repr(assert, "1/-2", "-1/2");
        repr(assert, "x/-2", "Mul(Var(x),-1/2)");
        repr(assert, "a+b", "Add(Var(a),Var(b))");
        repr(assert, "a+b+c", "Add(Var(a),Var(b),Var(c))");
        repr(assert, "a-b", "Add(Var(a),Mul(-1,Var(b)))");
        repr(assert, "a-b+c", "Add(Var(a),Mul(-1,Var(b)),Var(c))");
        repr(assert, "abc", "Mul(Var(a),Var(b),Var(c))");
        repr(assert, "a/bc", "Mul(Var(a),Pow(Var(b),-1),Var(c))");
        repr(assert, "a*(b+c)", "Mul(Var(a),Add(Var(b),Var(c)))");
        repr(assert, "x--y", "Add(Var(x),Mul(-1,-1,Var(y)))");
        repr(assert, "--y", "Mul(-1,-1,Var(y))");
        repr(assert, "e", "Const(e)");
        repr(assert, "2e", "Mul(2,Const(e))");
        repr(assert, "2e^x", "Mul(2,Pow(Const(e),Var(x)))");
        repr(assert, "cdef", "Mul(Var(c),Var(d),Const(e),Var(f))");
        repr(assert, "pi", "Const(pi)");
        repr(assert, "pi^2", "Pow(Const(pi),2)")
        repr(assert, "pir", "Mul(Const(pi),Var(r))");
        repr(assert, "pir^2", "Mul(Const(pi),Pow(Var(r),2))");
        repr(assert, "y=x^2", "Eq(Var(y),=,Pow(Var(x),2))");
        repr(assert, "log_2x", "Log(2,Var(x))");
        repr(assert, "f(x+y)", "Mul(Var(f),Add(Var(x),Var(y)))");
        repr(assert, "f(x+y)", "Func(f,Add(Var(x),Var(y)))", {functions: ["f"]});
        repr(assert, "sin(theta)", "Trig(sin,Var(theta))");
        repr(assert, "tanh(theta)", "Trig(tanh,Var(theta))");

        // verify that negative signs get folded into numbers
        repr(assert, "-x*3", "Mul(Var(x),-3)");
        repr(assert, "sin -x*3", "Trig(sin,Mul(Var(x),-3))");
    });


    QUnit.module("rendering");

    var tex = function(assert, input, expected, options) {
        var message = input + " renders as " + expected;
        assert.strictEqual(parse(input, options).tex(), expected, message);
    };

    QUnit.test("positive and negative primitives", function(assert) {
        tex(assert, "0", "0");
        tex(assert, "-1", "-1");
        tex(assert, "--1", "--1");
        tex(assert, "-2", "-2");
        tex(assert, "--2", "--2");
        tex(assert, "x", "x");
        tex(assert, "theta", "\\theta");
        tex(assert, "1/2", "\\frac{1}{2}");
        tex(assert, "-1/2", "-\\frac{1}{2}");
        tex(assert, "1/-2", "-\\frac{1}{2}");
        tex(assert, "-1/-2", "--\\frac{1}{2}");
    });

    QUnit.test("addition", function(assert) {
        tex(assert, "1-2", "1-2");
        tex(assert, "a+b", "a+b");
        tex(assert, "a-b", "a-b");
        tex(assert, "a-1b", "a-1b");
        tex(assert, "a+-b", "a+-b");
        tex(assert, "a+-1b", "a+-1b");
    });

    QUnit.test("multiplication", function(assert) {
        tex(assert, "ab", "ab");
        tex(assert, "a*b", "ab");
        tex(assert, "a/b", "\\frac{a}{b}");
        tex(assert, "a/bc/d", "\\frac{ac}{bd}");

        tex(assert, "1/(x+y)", "\\frac{1}{x+y}");
        tex(assert, "2/(x+y)", "\\frac{2}{x+y}");
        tex(assert, "(z+2)/(x+y)", "\\frac{z+2}{x+y}");
        tex(assert, "(z+2)/4", "\\frac{z+2}{4}");
    });

    QUnit.test("rational expressions", function(assert) {
        tex(assert, "x+1/2", "x+\\frac{1}{2}");
        tex(assert, "x-1/2", "x-\\frac{1}{2}");

        tex(assert, "1/2x", "\\frac{1}{2}x");
        tex(assert, "1/2x/y", "\\frac{1}{2}\\frac{x}{y}");
        tex(assert, "5*1/2x/y", "\\frac{1}{2}\\frac{5x}{y}");
        tex(assert, "1/2*4*x/y", "\\frac{1}{2}\\frac{4x}{y}");
        tex(assert, "-1/2x", "-\\frac{1}{2}x");
        tex(assert, "a-1/2x", "a-\\frac{1}{2}x");

        tex(assert, "1/(2x)", "\\frac{1}{2x}");
        tex(assert, "8/(7p^4)", "\\frac{8}{7p^{4}}");

        tex(assert, "x/2", "\\frac{x}{2}");
        tex(assert, "1x/2", "\\frac{1x}{2}");
        tex(assert, "-x/2", "-\\frac{x}{2}");
        tex(assert, "x/-2", "-\\frac{x}{2}");
        tex(assert, "x/-2/-3", "--\\frac{x}{2 \\cdot 3}");
        tex(assert, "--x/2/3", "--\\frac{x}{2 \\cdot 3}");
        tex(assert, "a-x/2", "a-\\frac{x}{2}");

        tex(assert, "1*-2", "1 \\cdot -2");
        tex(assert, "1*-2*3", "1 \\cdot -2 \\cdot 3");
        tex(assert, "1*-2*3/4", "1 \\cdot -2 \\cdot \\frac{3}{4}");
        tex(assert, "1*-2*3/4/5", "1 \\cdot -2 \\cdot \\frac{3}{4} \\cdot \\frac{1}{5}");
        tex(assert, "1/2*1/2", "\\frac{1}{2} \\cdot \\frac{1}{2}");
    });

    QUnit.test("exponentiation", function(assert) {
        tex(assert, "x^y", "x^{y}");
        tex(assert, "xy^z", "xy^{z}");
        tex(assert, "(xy)^z", "(xy)^{z}");
        tex(assert, "(x+y)^z", "(x+y)^{z}");
        tex(assert, "x^(yz)", "x^{yz}");
        tex(assert, "x^-(yz)", "x^{-yz}");
        tex(assert, "x^(y+z)", "x^{y+z}");
        tex(assert, "x^-(y+z)", "x^{-(y+z)}");
        tex(assert, "(x^y)^z", "(x^{y})^{z}");
        tex(assert, "pir^2", "\\pi r^{2}");
    });

    QUnit.test("square root", function(assert) {
        tex(assert, "sqrt(x)", "\\sqrt{x}");
        tex(assert, "sqrt(x)y", "\\sqrt{x}y");
        tex(assert, "1/sqrt(x)", "\\frac{1}{\\sqrt{x}}");
        tex(assert, "1/sqrt(x)y", "\\frac{y}{\\sqrt{x}}");

        tex(assert, "sqrt(2)/2", "\\frac{\\sqrt{2}}{2}");
        tex(assert, "sqrt(2)^2", "(\\sqrt{2})^{2}");
    });

    QUnit.test("nth root", function(assert) {
        // This is an unfortunate case, but only nth degree roots with integer
        // n's get nicely printed as tex.
        tex(assert, "sqrt[z]{x}", "x^{\\frac{1}{z}}");

        tex(assert, "sqrt[3]{x}", "\\sqrt[3]{x}");
        tex(assert, "sqrt[3]{x}z", "\\sqrt[3]{x}z");
        tex(assert, "1/sqrt[4]{x}", "\\frac{1}{\\sqrt[4]{x}}");
        tex(assert, "1/sqrt[4]{x}y", "\\frac{y}{\\sqrt[4]{x}}");

        tex(assert, "sqrt[9]{2}/2", "\\frac{\\sqrt[9]{2}}{2}");
        tex(assert, "sqrt[9]{2}^2", "(\\sqrt[9]{2})^{2}");
    });

    QUnit.test("absolute value", function(assert) {
        tex(assert, "|x|", "\\left|x\\right|");
        tex(assert, "|x|y", "\\left|x\\right|y");
    })

    QUnit.test("logarithms", function(assert) {
        tex(assert, "lnx", "\\ln(x)");
        tex(assert, "logx", "\\log_{10}(x)");
        tex(assert, "lnx^y", "\\ln(x^{y})");
        tex(assert, "logx^y", "\\log_{10}(x^{y})");
        tex(assert, "(lnx)^y", "[\\ln(x)]^{y}");
        tex(assert, "(logx)^y", "[\\log_{10}(x)]^{y}");
    });

    QUnit.test("trig functions", function(assert) {
        tex(assert, "sinx", "\\sin(x)");

        tex(assert, "arcsin x", "\\arcsin(x)");
        tex(assert, "sin^-1 x", "\\arcsin(x)");

        tex(assert, "(sinx)^2", "\\sin^{2}(x)");
        tex(assert, "sin^2 x", "\\sin^{2}(x)");

        tex(assert, "1/(sinx)^2", "\\frac{1}{\\sin^{2}(x)}");
        tex(assert, "1/sin^2x", "\\frac{1}{\\sin^{2}(x)}");

        tex(assert, "sin^2 x + cos^2 x = 1", "\\sin^{2}(x)+\\cos^{2}(x) = 1");
    });

    QUnit.test("hyperbolic functions", function(assert) {
        tex(assert, "sinhx", "\\sinh(x)");
        tex(assert, "sinh^2 x", "\\sinh^{2}(x)");
    });

    QUnit.test("multiplication with numbers", function(assert) {
        tex(assert, "4*10", "4 \\cdot 10");
        tex(assert, "10^5", "10^{5}");
        tex(assert, "4*10^5", "4 \\cdot 10^{5}");
        tex(assert, "10^5x", "10^{5}x");
        tex(assert, "4*10^5x", "4 \\cdot 10^{5}x");
        tex(assert, "x*(10+4)^5", "x(10+4)^{5}");

        tex(assert, "-1*2", "-1 \\cdot 2");
        tex(assert, "1*-2", "1 \\cdot -2");
        tex(assert, "-1*-2", "-1 \\cdot -2");
        tex(assert, "-1*2*3", "-1 \\cdot 2 \\cdot 3");
    });

    QUnit.test("inverses and division", function(assert) {
        tex(assert, "x^-1", "x^{-1}");
        tex(assert, "2x^-1", "2x^{-1}");
        tex(assert, "1/x", "\\frac{1}{x}");
        tex(assert, "-1/x", "\\frac{-1}{x}");
        tex(assert, "2/x", "\\frac{2}{x}");
        tex(assert, "1/x^2", "\\frac{1}{x^{2}}");
        tex(assert, "2/x^2", "\\frac{2}{x^{2}}");
        tex(assert, "1/1/x", "\\frac{1}{x}");
        tex(assert, "1/(1/x)", "\\frac{1}{\\frac{1}{x}}");
        tex(assert, "1/x/x", "\\frac{1}{xx}");
        tex(assert, "1/(x/x)", "\\frac{1}{\\frac{x}{x}}");
        tex(assert, "-1/1/x", "\\frac{-1}{x}");
        tex(assert, "-1/(1/x)", "\\frac{-1}{\\frac{1}{x}}");
        tex(assert, "-1/x/x", "\\frac{-1}{xx}");
        tex(assert, "-1/(x/x)", "\\frac{-1}{\\frac{x}{x}}");
    });

    QUnit.test("distributive property", function(assert) {
        tex(assert, "ab+c", "ab+c");
        tex(assert, "ab+ac", "ab+ac");
        tex(assert, "a(b+c)", "a(b+c)");
    });

    QUnit.test("numerical exponents", function(assert) {
        tex(assert, "9^4", "9^{4}");
        tex(assert, "-9^4", "-9^{4}");
        tex(assert, "1-9^4", "1-9^{4}");
    });

    QUnit.test("negating a Mul", function(assert) {
        tex(assert, "-3x", "-3x");
        tex(assert, "--3x", "--3x");
        tex(assert, "-x*3", "-3x");
        tex(assert, "--x*3", "--3x");
    });

    QUnit.test("equations", function(assert) {
        tex(assert, "y=x", "y = x");
        tex(assert, "y<x", "y < x");
        tex(assert, "y>x", "y > x");
        tex(assert, "y<>x", "y \\ne x");
        tex(assert, "y=/=x", "y \\ne x");
        tex(assert, "y<=x", "y \\le x");
        tex(assert, "y>=x", "y \\ge x");
        print(assert, "y \\le x", "y<=x");
        print(assert, "y \\leq x", "y<=x");
        print(assert, "y \\ge x", "y>=x");
        print(assert, "y \\geq x", "y>=x");
    });

    QUnit.test("function variables", function(assert) {
        tex(assert, "f(x)", "fx");
        tex(assert, "f(x)", "f(x)", {functions: ["f"]});
        tex(assert, "f(sin x)", "f(\\sin(x))", {functions: ["f"]});
        tex(assert, "sin f(x)", "\\sin(f(x))", {functions: ["f"]});
    });

    var texopt = function(assert, input, expected) {
        var options = {
            display: false,
            dynamic: false,
            times: false
        };
        var optlist = _.toArray(arguments).slice(2);
        _.each(optlist, function(opt) { options[opt] = true; });

        var message = input + " renders with options as " + expected;
        assert.strictEqual(parse(input).asTex(options), expected, message);
    };

    QUnit.test("options", function(assert) {
        texopt(assert, "x", "x");
        texopt(assert, "x", "\\displaystyle x", "display");
        texopt(assert, "a(b+c(d+e))", "a(b+c(d+e))");
        texopt(assert, "a(b+c(d+e))", "a\\left(b+c\\left(d+e\\right)\\right)", "dynamic");
        texopt(assert, "2*2", "2 \\cdot 2");
        texopt(assert, "2*2", "2 \\times 2", "times");

        texopt(assert, "1*2(3+4)", "\\displaystyle 1 \\times 2\\left(3+4\\right)",
            "display", "dynamic", "times");
    });


    QUnit.module("evaluating");

    var val = function(assert, input, expected, vars, functions) {
        if (vars === undefined) vars = {};
        var message = input + " evaluates as " + expected;
        assert.strictEqual(parse(input, {functions: functions}).eval(vars, {functions: functions}), expected, message);
    };

    QUnit.test("empty", function(assert) {
        val(assert, "", 0);
    });

    QUnit.test("simple expressions", function(assert) {
        val(assert, "1+2+3+4", 10);
        val(assert, "1+2-3+4", 4);
        val(assert, "1*2*3*4", 24);
        val(assert, "1*2/3*4", 2 + 2/3);
        val(assert, "4^3^2^1", 262144);
        val(assert, "-1", -1);
        val(assert, "--1", 1);
        val(assert, "---1", -1);
        val(assert, "2^-2", .25);
        val(assert, "8^(1/3)", 2);
        val(assert, "0^0", 1);
        val(assert, ".25*4", 1);
        val(assert, "ln e", 1);
        val(assert, "log 10", 1);
        val(assert, "log_2 2", 1);
    });

    QUnit.test("hyperbolic expressions", function(assert) {
        val(assert, "cosh(0.2)", 1.020066755619076);
        val(assert, "coth(0.2)", 5.066489563439473);
        val(assert, "csch(3 * 2)", 0.00495753481347936);
    });

    QUnit.test("variable expressions", function(assert) {
        val(assert, "x", 3, {x: 3});
        val(assert, "x^2", 9, {x: 3});
        val(assert, "(x^2+y^2)^.5", 5, {x: 3, y: 4});
        val(assert, "log x_0", 1, {x_0: 10});
        val(assert, "log x_0 + log x_1", 3, {x_0: 10, x_1: 100});
        val(assert, "log x_42", 1, {x_42: 10});
        val(assert, "x_a + x_bc", 7, {x_a: 1, x_b: 2, c: 3});
    });

    QUnit.test("function expressions", function(assert) {
        val(assert, "f(2)", 4, {"f": "2x"}, ["f"]);
        val(assert, "f(4+8)", 48, {"f": "4x"}, ["f"]);
        val(assert, "f(x-1)-f(x)", -7, {"f": "x^3", "x": 2}, ["f"]);
        val(assert, "g(1)", -1, {f: "x", g: "-f(x)"}, ["f", "g"]);
    });

    QUnit.module("compilation");

    var compile = function(assert, input, expected, vars, functions) {
        if (vars === undefined) vars = {};
        var func = parse(input, {functions: functions}).compile();
        var result;
        try {
            result = func(vars);
        } catch (e) {
            throw new Error("invalid function: " + func.toString());
        }
        var message = input + " should evaluate to " + expected +
			", was " + result + "; by func: " + func.toString();
        assert.ok(Math.abs(result - expected) < 1e-9, message);
    };

    QUnit.test("empty", function(assert) {
        compile(assert, "", 0);
    });

    QUnit.test("simple expressions", function(assert) {
        compile(assert, "1+2+3+4", 10);
        compile(assert, "1+2-3+4", 4);
        compile(assert, "1*2*3*4", 24);
        compile(assert, "1*2/3*4", 2 + 2/3);
        compile(assert, "4^3^2^1", 262144);
        compile(assert, "-1", -1);
        compile(assert, "--1", 1);
        compile(assert, "---1", -1);
        compile(assert, "2^-2", .25);
        compile(assert, "8^(1/3)", 2);
        compile(assert, "0^0", 1);
        compile(assert, ".25*4", 1);
        compile(assert, "ln e", 1);
        compile(assert, "log 10", 1);
        compile(assert, "log_2 2", 1);
    });

    QUnit.test("variable expressions", function(assert) {
        compile(assert, "x", 3, {x: 3});
        compile(assert, "x^2", 9, {x: 3});
        compile(assert, "(x^2+y^2)^.5", 5, {x: 3, y: 4});
        compile(assert, "log x_0", 1, {x_0: 10});
        compile(assert, "log x_0 + log x_1", 3, {x_0: 10, x_1: 100});
        compile(assert, "log x_42", 1, {x_42: 10});
        compile(assert, "x_a + x_bc", 7, {x_a: 1, x_b: 2, c: 3});
    });

    QUnit.test("function expressions", function(assert) {
        compile(assert, "f(2)", 4, {"f": function(x) { return 2 * x; }}, ["f"]);
        compile(assert, "f(4+8)", 48, {"f": function(x) { return 4 * x; }}, ["f"]);
        compile(assert, "f(x-1)-f(x)", -7, {"f": function(x) { return Math.pow(x, 3); }, "x": 2}, ["f"]);
    });

    QUnit.test("trig expressions", function(assert) {
        compile(assert, "-2sin(pi x) + 4", 4, {x: 32});
        compile(assert, "sin(pi x)", 0, {x: 6});
        compile(assert, "sin(x)", 1, {x: Math.PI / 2});
        compile(assert, "sin(pi x)", -1, {x: 3/2});
        compile(assert, "cos(x)", 1, {x: 0});
        compile(assert, "cos x", -1, {x: Math.PI});
        compile(assert, "tan(x)", 0, {x: 0});
        compile(assert, "tan x", 1, {x: Math.PI / 4});
    });

    QUnit.module("checking form");

    var norm = function(assert, input, reference) {
        var actual = parse(input).normalize().print();
        var expected = parse(reference).normalize().print();
        var message = input + " is the same as " + reference;
        assert.strictEqual(actual, expected, message);
    };

    QUnit.test("normalize", function(assert) {
        norm(assert, "ab", "ba");
        norm(assert, "(ab)c", "(cb)a");

        var forms = [
            "(6x+1)(x-1)",
            "(1+6x)(x-1)",
            "(6x+1)(-1+x)",
            "(1+6x)(-1+x)",
            "(x-1)(6x+1)",
            "(x-1)(1+6x)",
            "(-1+x)(6x+1)",
            "(-1+x)(1+6x)"
        ];

        _.each(forms, function(form) {
            norm(assert, forms[0], form);
        });
    });

    var stripnorm = function(assert, input, reference) {
        var actual = parse(input).strip().normalize().print();
        var expected = parse(reference).strip().normalize().print();
        var message = input + " is the same as " + reference;
        assert.strictEqual(actual, expected, message);
    };

    QUnit.test("strip then normalize", function(assert) {
        stripnorm(assert, "ab", "ba");
        stripnorm(assert, "(ab)c", "(cb)a");

        var forms = [
            "(6x+1)(x-1)",
            "(1+6x)(x-1)",
            "(6x+1)(-1+x)",
            "(1+6x)(-1+x)",
            "(-6x-1)(-x+1)",
            "(-1-6x)(-x+1)",
            "(-6x-1)(1-x)",
            "(-1-6x)(1-x)",
            "(x-1)(6x+1)",
            "(x-1)(1+6x)",
            "(-1+x)(6x+1)",
            "(-1+x)(1+6x)",
            "(-x+1)(-6x-1)",
            "(-x+1)(-1-6x)",
            "(1-x)(-6x-1)",
            "(1-x)(-1-6x)",
            "-(6x+1)(1-x)",
            "-(-6x-1)(x-1)"
        ];

        _.each(forms, function(form) {
            stripnorm(assert, forms[0], form);
        });
    })


    QUnit.module("equation to expression");

    var asExpr = function(assert, input, reference) {
        var actual = parse(input).asExpr().simplify().normalize().print();
        var expected = parse(reference).normalize().print();
        var message = input + " as an expression is " + reference;
        assert.strictEqual(actual, expected, message);
    };

    QUnit.test("", function(assert) {
        var forms = [
            "y=2x-5",
            "-2x+5=-y",
            "2x-5<>y",
            "2x-y<>5",
            "(y+5)/2=x",
            "(y+5)/x=2",
            "1/2(y+5)=x",
            ".5(y+5)=x",
            "y-3=2(x-4)",
            "2y=4x-10",
            "yz=2xz-5z"
        ];

        _.each(forms, function(form) {
            if (form.indexOf("<>") !== -1) {
                asExpr(assert, form, "-y+2x-5");
            } else {
                asExpr(assert, form, "y-2x+5");
            }
        });

        var forms2 = [
            "1/3p-3=114",
            "1/3p=117",
            "p=351",
            "p-351=0",
        ];

        _.each(forms2, function(form) {
            asExpr(assert, form, "p-351");
        });
    });


    QUnit.module("comparing");

    var compare = function(assert, options, input, reference, expectedResult) {
        var actual = parse(input, {functions: ["f", "g", "h"]});
        var expected = parse(reference, {functions: ["f", "g", "h"]});
        var result = KAS.compare(actual, expected, options);
        if (expectedResult === undefined) expectedResult = true;
        var message = input + " is " + (expectedResult ? "" : "NOT ") + "the same as " + reference;
        assert.equal(result.equal, expectedResult, message);
    };

    QUnit.test("evaluate only", function(assert) {
        var comp = _.partial(compare, assert, {form: false});

        comp("2+2", "4");
        comp("a(b+c)", "ab+ac");
        comp("a/b", "a*b^-1");

        comp("1.2^2", "1.44");
        comp("1.3^2", "1.69");
        comp("1.4^2", "1.96");
        comp("1.5^2", "2.25");

        comp("1.2345^2", "1.52399025");
        comp("1.2345*1.2345", "1.52399025");
        comp("(1+.2345)^2", "1.52399025");
        comp("(-5)^(1/3)", "-1.709975946");
        comp("(-5)^(2/6)", "-1.709975946");
        comp("(-5)^(4/3)", "8.549879733");
        comp("(-5)^(-1/3)", "-0.584803547");

        comp("(-5)^(1/5)",  "-1.379729661");
        comp("(-5)^(0.2)",  "-1.379729661");

        comp("x^(1/5)", "x^(0.2)");
        comp("x^(8/5)", "x^(1.6)");

        comp("(1-x)(-1-6x)", "(6x+1)(x-1)");
        comp("y=x", "x", false);
        comp("x", "y=x", false);
        comp("y=x", "y=x");
        comp("y=x", "x=y");
        comp("y=x", "-y=-x");
        comp("y=x", "-x=-y");
        comp("y=x", "y=-x", false);
        comp("y=x", "-y=x", false);
        comp("y=x", "y=/=x", false);
        comp("y<x", "x>y");
        comp("y<=x", "x>=y");
        comp("y>x", "x<y");
        comp("y>x", "x>y", false);
        comp("y>=x", "x<=y");
        comp("a+b<c-d", "a+b-c+d<0");

        comp("y=mx+b", "-b-mx=-y");
        comp("y=mx+b", "y-b=mx");

        // all of these normalize to the same expression, set to zero
        var forms = [
            "y=2x-5",
            "2x-5=y",
            "2x-y=5",
            "(y+5)/2=x",
            "(y+5)/x=2",
            "1/2(y+5)=x",
            ".5(y+5)=x",
            "y-3=2(x-4)",
            "2y=4x-10",
            "yz=2xz-5z"
        ];

        _.each(forms, function(form) {
            comp(forms[0], form);
        });

        comp("3y=2x-15", "3/2(y+5)=x");

        var forms2 = [
            "1/3p-3=114",
            "1/3p=117",
            "p=351",
            "p-351=0",
        ];

        _.each(forms2, function(form) {
            comp(forms2[0], form);
        });

        comp("x", "xy/y");
        comp("e^x", "e^x");
        comp("e^x", "e^x + 1", false);

        var forms3 = [
            "x+x+x+6=12",
            "x+2x+6=12",
            "3x+6=12",
            "x+2x=6",
            "2x=6-x",
            "3x=6",
            "x=2"
        ];

        _.each(forms3, function(form) {
            comp(forms3[0], form);
        });

        comp("100/55.6=t", "t=100/55.6");
        comp("100/1.6^2=t", "t=100/1.6^2");
        comp("7/3x+x=15", "(2+1/3)x+x=15");
        comp("7/3x+x=15", "(1+1/3)x+x=15", false);

        // Symmetric equations
        comp("x^2+y^2=r^2", "r^2=x^2+y^2");
        comp("23^1.5=110.304", "110.304=23^1.5");

        // TODO(alex): make sure that I have both positive and negative
        // test cases for all functionality
        comp("6.12*10^-2", "6.12*10^-2");
        comp("6.12*10^-2", "6.12*10^-6", false);

        comp("3^-x", "(1/3)^x");
        comp("(1/3)^-x", "3^x");
        comp("(3)^-x", "3^x", false);

        comp("5.6=x+0.4+5.2", "5.6=x+0.4+5.2");

        // Reciprocal trig functions
        comp("csc x", "1/sin x");
        comp("sec x", "1/cos x");
        comp("cot x", "1/tan x");
        comp("arccsc x", "arcsin (1/x)");
        comp("arcsec x", "arccos (1/x)");
        comp("arccot x", "arctan (1/x)");

        // Reciprocal hyperbolic trig functions
        comp("csch x", "1/sinh x");
        comp("sech x", "1/cosh x");
        comp("coth x", "1/tanh x");

        // Make sure trig functions that are the same for all integer values
        // are not the same
        comp("-2sin(pi x) + 4", "4", false);
        comp("2sin(pi x) + 4", "-2sin(pi x) + 4", false);
        comp("sin(pi x)", "0", false);
        comp("0", "sin(pi x)", false);
        comp("cos(pi x)", "cos(2 pi x)", false);
        comp("sin(pi x)", "sin(500pi x)", false);
        comp("sin(500pi x)", "sin(pi x)", false);

        // Check that floating point error isn't killing us
        // TODO(jack): These don't seem to test much; make better tests
        comp("0", "sin(7pi)");
        comp("sin(7pi)", "0");
        comp("0", "sin(500pi)");
        comp("sin(500pi)", "0");

        // Handle denominators the same way regardless of a fraction's format
        comp("x=1.2^2", "x=1.44");
        comp("x=1.2^2", "x=36/25");
        comp("x=1.44", "x=36/25");
        comp("x=1.44", "x=35/25", false);

        comp("x=1.2^(2y)", "x=1.44^y");
        comp("x=1.2^(2y)", "x=(36/25)^y");
        comp("x=1.44^y", "x=(36/25)^y");

        comp("x=1.3^2", "x=1.69");
        comp("x=1.4^2", "x=1.96");
        comp("x=1.5^2", "x=2.25");
        comp("x=1.5^2", "x=2.25");

        comp("x=1.2345^2", "x=1.52399025");
        comp("x=1.2345*1.2345", "x=1.52399025");
        comp("x=(1+.2345)^2", "x=1.52399025");
        comp("x=(1+.2345)^2", "x=1.52399022", false);

        // Varying small and large comparisons
        comp("1.1234567891235 * 10^200", "1.1234567891234 * 10^200");
        comp("1.1234567891235 * 10^200", "0.10", false);
        comp("0.10", "1.1234567891235 * 10^200", false);
        comp("0.50", "0.51", false);
        comp("0.51", "0.50", false);

        comp("1.00", "1.00");
        comp("0.9", "1.1", false);
        comp("1.1", "0.9", false);

        // Real-world examples of equivalent equations that are now accepted
        comp("12(1-r)^2+58(1-r)=10", "(1-r)(70-12r)=10");
        comp("720m+480(m-5)=42000", "720m+480m-2400=42000");
        comp("2w+50/w=25", "w(12.5-w)=25");
        comp("(n*(8+4n))/2>19206", "6n+2n(n-1)>19206");

        // Correctly handle exponents with negative bases and variables in exponent
        comp("( 2)^n", "( 2)^(n-1)", false);
        comp("( 2)^n", "( 2)^(n)");
        comp("( 2)^n", "( 2)^(n+1)", false);

        comp("(-2)^n", "(-2)^(n-1)", false);
        comp("(-2)^n", "(-2)^(n)");
        comp("(-2)^n", "(-2)^(n+1)", false);

        comp("(-2)^(a)", "(-2)^(ab)", false);
        comp("(-2)^(a)", "(-2)^(a^b)", false);

        // This is incorrect, but accurately captures the current behavior
        // See comment in `Expr.compare()` for more details
        comp("(-2)^(n+0.1)", "(-2)^(n+1.1)");
    });

    QUnit.test("simplify can't yet handle these", function(assert) {
        var comp = _.partial(compare, assert, {form: false});

        comp("sin(x + 2pi)", "sin(x)");
        comp("y = sin(x + 2pi)", "y = sin(x)");
        comp("sin^2(x)+cos^2(x)", "x/x");
        comp("y = sin^2(x)+cos^2(x)", "y = x/x");
    });

    QUnit.test("partially evaluating functions", function(assert) {
        var comp = _.partial(compare, assert, {form: false});

        comp("f(x)", "f(x)");
        comp("f(x)", "g(x)", false);
        comp("f(g(x))", "f(g(x))");
        comp("sin(f(3x-x))/cos(f(x+x))", "tan(f(2x))");
        comp("f(x) = sin(x + 2pi)", "f(x) = sin(x)");
        comp("f(x) = sin^2(x)+cos^2(x)", "f(x) = 1");
        comp("f(x) = ln|x|+c", "f(x)-ln|x|-c = 0");
    });

    QUnit.test("evaluating and comparing form", function(assert) {
        var comp = _.partial(compare, assert, {form: false});

        comp("ab", "ba");
        comp("(ab)c", "(cb)a");

        var forms = [
            "(6x+1)(x-1)",
            "(1+6x)(x-1)",
            "(6x+1)(-1+x)",
            "(1+6x)(-1+x)",
            "(-6x-1)(-x+1)",
            "(-1-6x)(-x+1)",
            "(-6x-1)(1-x)",
            "(-1-6x)(1-x)",
            "(x-1)(6x+1)",
            "(x-1)(1+6x)",
            "(-1+x)(6x+1)",
            "(-1+x)(1+6x)",
            "(-x+1)(-6x-1)",
            "(-x+1)(-1-6x)",
            "(1-x)(-6x-1)",
            "(1-x)(-1-6x)",
            "-(6x+1)(1-x)",
            "-(-6x-1)(x-1)"
        ];

        _.each(forms, function(form) {
            comp(forms[0], form);
        });

        comp("(6x+1)(x+1)", "(6x+1)(x-1)", false);
        comp("a-b-c", "c+b+a", false);

        comp("(6x+1)(x+1)", "(6x+1)(x-1)", false);
        comp("a-b-c", "c+b+a", false);
        comp("mx+b", "b+mx");

        comp("y=mx+b", "-b-mx=-y");
        comp("y=mx+b", "y-b=mx", false);

        comp("y-3=2(x-4)", "y=2x-5", false);
        comp("y-3=2(x-4)", "2x-y=5", false);
        comp("y=2x-5", "2x-y=5", false);
    });


    QUnit.module("findGCD");

    var findGCD = function(assert, a, b, reference) {
        var actual = parse(a).findGCD(parse(b)).repr();
        var expected = parse(reference).repr();

        var message = "(" + a + ").findGCD(" + b + ") = " + expected;
        assert.strictEqual(actual, expected, message);
    };

    QUnit.test("findGCD on ints", function(assert) {
        findGCD(assert, "40", "30", "10");
        findGCD(assert, "14", "21", "7");
        findGCD(assert, "13", "26", "13");
    });

    QUnit.test("findGCD on rationals", function(assert) {
        findGCD(assert, "40/3", "55/6", "5/6");
        findGCD(assert, "3/4", "1/2", "1/4");
        findGCD(assert, "3/7", "12/22", "3/77");
        findGCD(assert, "3/10", "4/15", "1/30");
        findGCD(assert, "2/3", "23/6", "1/6");
        findGCD(assert, "2/3", "22/6", "1/3");

        findGCD(assert, "2/3", "2", "2/3");
        findGCD(assert, "2/3", "3", "1/3");
        findGCD(assert, "1/2", "4", "1/2");
        findGCD(assert, "4", "3/4", "1/4");
        findGCD(assert, "3", "3/4", "3/4");
    });

    QUnit.test("findGCD on floats", function(assert) {
        // Feel free to change this when we do something other
        // than a naive "return 1" for floats
        findGCD(assert, "1.23", "1.42", "1");
        findGCD(assert, "1", String(Math.PI), "1");
    });

    QUnit.module("transforming");

    var factor = function(assert, input, reference) {
        var actual = parse(input).factor().normalize().repr();
        var expected = parse(reference).normalize().repr();
        var message = input + " factors as " + reference;
        assert.strictEqual(actual, expected, message);
    };

    QUnit.test("factoring Adds", function(assert) {
        factor(assert, "2+2", "2(1+1)");
        factor(assert, "-2-2", "-2(1+1)");
        factor(assert, "2x+2", "2(x+1)");
        factor(assert, "x^3+x^2", "x^2(x+1)");
        factor(assert, "2x+xy", "x(2+y)");
        factor(assert, "2xy+xy^2", "xy(2+y)");
        factor(assert, "2+2/3", "2/3(3+1)");  // a little questionable, but 2/3 is what
                                      // wolframalpha returns for the gcd, so
                                      // we pull it out
        factor(assert, "2x+1.1", "2x+1.1");
    });

    QUnit.test("factoring Muls", function(assert) {
        factor(assert, "(2x+2)/(x+1)", "2 (x+1)/(x+1)");
        factor(assert, "(x+1)/(2x+2)", "1/2 (x+1)/(x+1)");
    });

    QUnit.test("factoring Pows", function(assert) {
        factor(assert, "x^y+x^(2y)", "x^y(1+x^y)");
        factor(assert, "x^y+x^z", "x^y+x^z");
    });

    var expand = function(assert, input, reference) {
        var actual = parse(input).expand().normalize().print();
        var expected = parse(reference).normalize().print();
        var message = input + " expands as " + reference;
        assert.strictEqual(actual, expected, message);
    };

    var expandrepr = function(assert, input, expected) {
        var actual = parse(input).expand().repr();
        var message = input + " expands as " + expected;
        assert.strictEqual(actual, expected, message);
    };

    var expandtex = function(assert, input, expected) {
        var actual = parse(input).expand().tex();
        var message = input + " expands and is rendered as " + expected;
        assert.strictEqual(actual, expected, message);
    };

    QUnit.test("distribute over multiplication", function(assert) {
        expand(assert, "a(b+c)", "ab+ac");
        expandtex(assert, "a(b+c)", "ab+ac");
        expandrepr(assert, "a(b+c)", "Add(Mul(Var(a),Var(b)),Mul(Var(a),Var(c)))");

        expand(assert, "a(b-c)", "ab-ac");
        expandtex(assert, "a(b-c)", "ab-ac");
        expandrepr(assert, "a(b-c)", "Add(Mul(Var(a),Var(b)),Mul(Var(a),-1,Var(c)))");

        expand(assert, "a(b+c)d", "abd+acd");
        expandrepr(assert, "a(b+c)d", "Add(Mul(Var(a),Var(d),Var(b)),Mul(Var(a),Var(d),Var(c)))");

        expand(assert, "(a+b)(c+d)", "ac+ad+bc+bd");
        expand(assert, "(a+b)(c+d)ef", "acef+adef+bcef+bdef");
        expand(assert, "(a+b)c^d", "ac^d+bc^d");
        expand(assert, "ab(c+d)e^f", "abce^f+abde^f");

        expand(assert, "(a+b(c+d))e", "ae+bce+bde");
        expandrepr(assert, "(a+b(c+d))e", "Add(Mul(Const(e),Var(a)),Mul(Const(e),Var(b),Var(c)),Mul(Const(e),Var(b),Var(d)))");
    });

    QUnit.test("distribute over rational expressions", function(assert) {
        expand(assert, "(a+b)/(c+d)", "(a+b)/(c+d)");
        expand(assert, "(a+b)/(c+d)*a", "(aa+ab)/(c+d)");
        expand(assert, "(a+b)/(c+d)*1/e", "(a+b)/(ce+de)");
        expand(assert, "(a+b)/(c+d)*a/e", "(aa+ab)/(ce+de)");
    });

    QUnit.test("expand exponentiation", function(assert) {
        expand(assert, "(ab)^2", "a^2 b^2");
        expand(assert, "2*(ab)^2", "2 a^2 b^2");
        expand(assert, "(a+b)^2", "a^2+2ab+b^2");

        expand(assert, "(ab)^-2", "a^-2 b^-2");
        expand(assert, "2*(ab)^-2", "2 a^-2 b^-2");
        expand(assert, "(a+b)^-2", "(a^2+2ab+b^2)^-1");
    });

    QUnit.test("expand absolute value", function(assert) {
        expand(assert, "|a+b|", "|a+b|");
        expand(assert, "|ab|", "|a|*|b|");
    });

    QUnit.test("expand logarithms", function(assert) {
        expand(assert, "ln(xy)", "lnx+lny");
        expand(assert, "log_b(x)", "lnx/lnb");
        expand(assert, "log_b(xy)", "lnx/lnb+lny/lnb");
        expand(assert, "ln(xy/z)", "lnx+lny-lnz");

        expand(assert, "ln(x^y)", "ylnx");
        expand(assert, "log_b(x^y)", "ylnx/lnb");
        expand(assert, "ln(x^y^z)", "y^zlnx");

        expand(assert, "ln(x^y/z)", "ylnx-lnz");

        // ln((xy)^z) -> ln(x^z*y^z) -> z*ln(x)+z*ln(y)
        expand(assert, "ln((xy)^z)", "zlnx+zlny");

        expand(assert, "log_b(x)log_x(y)", "ln(x)/ln(b)*ln(y)/ln(x)");
        expand(assert, "log_b(x)log_x(y)log_y(z)", "ln(x)/ln(b)*ln(y)/ln(x)*ln(z)/ln(y)");
    });

    QUnit.test("expand trig functions", function(assert) {
        expand(assert, "sin(x)", "sin(x)");
        expand(assert, "cos(x)", "cos(x)");
        expand(assert, "tan(x)", "sin(x)/cos(x)");
        expand(assert, "csc(x)", "1/sin(x)");
        expand(assert, "sec(x)", "1/cos(x)");
        expand(assert, "cot(x)", "cos(x)/sin(x)");
    });

    QUnit.test("expand hyperbolic functions", function(assert) {
        expand(assert, "sinh(x)", "sinh(x)");
        expand(assert, "cosh(x)", "cosh(x)");
        expand(assert, "tanh(x)", "sinh(x)/cosh(x)");
        expand(assert, "csch(x)", "1/sinh(x)");
        expand(assert, "sech(x)", "1/cosh(x)");
        expand(assert, "coth(x)", "cosh(x)/sinh(x)");
    });

    var collect = function(assert, input, reference) {
        var actual = parse(input).collect().normalize().print();
        var expected = parse(reference).normalize().print();
        var message = input + " collects as " + reference;
        assert.strictEqual(actual, expected, message);
    };

    var collectrepr = function(assert, input, expected) {
        var actual = parse(input).collect().repr();
        var message = input + " collects as " + expected;
        assert.strictEqual(actual, expected, message);
    };

    var collecttex = function(assert, input, expected) {
        var actual = parse(input).collect().tex();
        var message = input + " collects and is rendered as " + expected;
        assert.strictEqual(actual, expected, message);
    };

    QUnit.test("collect over addition", function(assert) {
        collect(assert, "", "0");
        collect(assert, "0", "0");
        collect(assert, "1+3", "4");
        collect(assert, "x+3", "3+x");
        collect(assert, "x+3x", "4x");
        collectrepr(assert, "x+3x", "Mul(4,Var(x))");
        collect(assert, "a+a+a", "3a");
        collectrepr(assert, "a+a+a", "Mul(3,Var(a))");
        collect(assert, "a+b+b+c", "a+2b+c");
        collectrepr(assert, "a+b+b+c", "Add(Var(a),Mul(2,Var(b)),Var(c))");
        collect(assert, "4x^2-x^2+8x+7-5x-4", "3+3x+3x^2");
    });

    QUnit.test("collect over multiplication", function(assert) {
        collect(assert, "5*7", "35");
        collect(assert, "5*7x+20x", "55x");
        collect(assert, "3x*xy+2yx^2", "5x^2y");
        collect(assert, "4/6", "2/3");
        collect(assert, "1/1", "1");
        collect(assert, "1/2+1/3", "5/6");
        collect(assert, "1/2+1/3+1", "11/6");
        collect(assert, "1.2+1/2", "1.7");
        collect(assert, "1/2-1/2", "0");
        collect(assert, "1/2-.5", "0");
    });

    QUnit.test("collect over exponentiation", function(assert) {
        collect(assert, "x^0", "1");
        collect(assert, "x^1", "x");
        collect(assert, "x^(log_x y)", "y");
        collect(assert, "(x^y)^z", "x^(yz)");
        collect(assert, "0^0", "1");
        collect(assert, "4^1.5", "8");
        collect(assert, "(2/3)^2", "4/9");
        collect(assert, "(2/3)^-2", "9/4");
    });

    QUnit.test("collect over roots", function(assert) {
        collect(assert, "sqrt(2)^2", "2");
        collect(assert, "sqrt[3]{3}^3", "3");
        collect(assert, "(2^(1/3))^3", "2");
    });

    QUnit.test("collect over absolute value", function(assert) {
        collect(assert, "|x|", "|x|");
        collect(assert, "|2|", "2");
        collect(assert, "|0|", "0");
        collect(assert, "|-2|", "2");
        collect(assert, "|pi|", "pi");
        collect(assert, "|2^x|", "2^x");
        collect(assert, "|x^2|", "x^2");
        collect(assert, "|-2pix^2y^3|", "2pix^2*|y^3|");
    });

    QUnit.test("collect over logarithms", function(assert) {
        collect(assert, "log(1)", "0");
        collect(assert, "log_x(x)", "1");
        collect(assert, "log_b(b^x)", "x");

        collect(assert, "b^(2*y*log_b x)", "x^(2y)");
        collect(assert, "b^(log_b a) b^(-log_b c)", "a/c");

        collect(assert, "ln(x)/ln(b)", "log_b(x)");
        collect(assert, "ln(x)/ln(b)*ln(y)/ln(x)", "log_b(y)");
        collect(assert, "ln(x)/ln(b)*ln(y)/ln(x)*ln(z)/ln(y)", "log_b(z)");
    });

    QUnit.test("collect trig functions", function(assert) {
        collect(assert, "sin(x)cos(x)", "sin(x)cos(x)");
        collect(assert, "sin(x)/cos(x)", "tan(x)");

        collect(assert, "sin^2(x)/cos^2(x)", "tan^2(x)");
        collect(assert, "cos^2(x)/sin^2(x)", "cot^2(x)");

        collect(assert, "sin^-2(x)/cos^-2(x)", "cot^2(x)");
        collect(assert, "cos^-2(x)/sin^-2(x)", "tan^2(x)");

        collect(assert, "sin^--2(x)/cos^--2(x)", "tan^2(x)");
        collect(assert, "cos^--2(x)/sin^--2(x)", "cot^2(x)");

        collect(assert, "sin^2(x)/cos(x)", "sin^2(x)/cos(x)");
        collect(assert, "sin(x)/cos^2(x)", "sin(x)/cos^2(x)");

        collect(assert, "sin(-x)", "-sin(x)");
        collect(assert, "cos(-x)", "cos(x)");
        collect(assert, "tan(-x)", "-tan(x)");
        collect(assert, "csc(-x)", "-csc(x)");
        collect(assert, "sec(-x)", "sec(x)");
        collect(assert, "cot(-x)", "-cot(x)");

        collect(assert, "sin(--x)", "sin(x)");
        collect(assert, "arcsin(-x)", "arcsin(-x)");

        collect(assert, "sin(-x)cos(-x)", "-sin(x)cos(x)");
        collect(assert, "sin(-x)/cos(-x)", "-tan(x)");
    });

    QUnit.test("collect then output tex", function(assert) {
        // user-friendly tex representation is not guaranteed after collect(assert, )
        collect(assert, "-x", "-1x");
        collecttex(assert, "-x", "-1x");
        collect(assert, "a-b", "a+-1b");
        collecttex(assert, "a-b", "a+-1b");
        collect(assert, "a/b", "ab^-1");
        collecttex(assert, "a/b", "ab^{-1}");
    });

    QUnit.test("collect over an equation", function(assert) {
        // collect does not try to collect across both sides of an equation
        collect(assert, "y+1-1=x*x", "y=x^(2)");
        collect(assert, "1+y=1+x^2", "1+y=1+x^(2)");
    });

    var simplify = function(assert, input, reference) {
        var actual = parse(input).simplify().normalize().print();
        var expected = parse(reference).normalize().print();
        var message = input + " simplifies as " + reference;
        assert.strictEqual(actual, expected, message);
    };

    QUnit.test("simplify", function(assert) {
        simplify(assert, "(a+b)^2", "(a+b)^2");
        simplify(assert, "(a+b)(a+b)", "(a+b)^2");

        // (ab)^2 ->[factor]-> a^2 * b^2 ->[collect]-> a^2 * b^2
        // (no change during collect, therefore factoring is rolled back)
        simplify(assert, "(ab)^2", "(ab)^2");

        // (3x)^2 ->[factor]-> 3^2 * x^2 ->[collect]-> 9x^2
        // (changed during collect, therefore factoring persists)
        simplify(assert, "(3x)^2", "9x^2");

        simplify(assert, "(2sqrt(2))^4", "64");
        simplify(assert, "(3sqrt[3]{3})^9", "531441");

        // from "Simplifying expressions with exponents"
        simplify(assert, "((nx^5)^5)", "n^5 x^25");
        simplify(assert, "((nx^5)^5)/2", "1/2 n^5 x^25");
        simplify(assert, "((nx^5)^5)/(n^-2x^2)^-3", "n^-1 x^31");

        simplify(assert, "1/(xya)+1/(xyb)", "1/(xya)+1/(xyb)");

        // Simplify rationals correctly
        simplify(assert, "2*(x+1/3)", "2*x+2/3");
        simplify(assert, "-1*(1/3+x)", "-1*x+-1/3");
    });

    QUnit.module("units");

    var unitEq = function(assert, x, y, msg) {
        assert.ok(KAS.compare(x.simplify(), y.simplify()).equal, msg);
    };

    var unitNeq = function(assert, x, y, msg) {
        assert.ok(!KAS.compare(x.simplify(), y.simplify()).equal, msg);
    };

    var parseEq = function(assert, x, y, msg) {
        unitEq(assert, KAS.unitParse(x).expr, KAS.unitParse(y).expr, msg);
    };

    var parseNeq = function(assert, x, y, msg) {
        unitNeq(assert, KAS.unitParse(x).expr, KAS.unitParse(y).expr, msg);
    };

    var solveUnitVariable = function(assert, original, newUnit, expected) {
        var originalParsed = KAS.unitParse(original).expr;
        var newUnitParsed = KAS.unitParse(newUnit).unit;
        var x = new KAS.Var("x");
        var equality = new KAS.Eq(
            originalParsed,
            "=",
            new KAS.Mul(x, newUnitParsed)
        );
        var answer = equality.solveLinearEquationForVariable(x);

        var msg = original + " = [" + expected.print() + "] " + newUnit;
        assert.ok(Math.round(answer.eval()) == Math.round(expected.eval()), msg);
    };

    var formEq = function(x, y) {
        return KAS.compare(
            KAS.unitParse(x).unit,
            KAS.unitParse(y).unit
        ).equal;
    };

    var parseMagnitude = function(assert, str, expected) {
        var parsed = KAS.unitParse(str).coefficient;
        assert.ok(+parsed, expected);
    };

    QUnit.test("simplify expressions with units", function(assert) {
        unitEq(
            assert,
            new KAS.Mul(new KAS.Rational(1, 100), new KAS.Unit("cup")),
            new KAS.Mul(new KAS.Rational(1, 400), new KAS.Unit("qt")),
            "1/100 cup = 1 / 400 quart"
        );

        parseEq(assert, "10 g", "0.01 kg", "10 g = 1 / 100 kg");

        parseEq(assert, "9.8 kg m / s^2", "9.8 N", "9.8 kg m / s^2 = 9.8 N");

        parseEq(assert, "9.8 m / s^2", "9.8 N / kg", "9.8 m / s^2 = 9.8 N / kg");

        unitEq(
            assert,
            new KAS.Mul(new KAS.Float(9.8),
                        new KAS.Unit("m"),
                        new KAS.Pow(new KAS.Unit("s"), new KAS.Int(-2))),
            new KAS.Mul(new KAS.Float(9.8),
                        new KAS.Pow(new KAS.Unit("s"), new KAS.Int(-2)),
                        new KAS.Unit("m")),
            "9.8 m / s^2 = 9.8 s^-2 m"
        );

        unitEq(
            assert,
            new KAS.Mul(new KAS.Int(50),
                        new KAS.Unit("m"),
                        new KAS.Pow(new KAS.Unit("m"), new KAS.Int(-1))),
            new KAS.Int(50),
            "50 m / m = 50"
        );

        // There's a long chain of conversions before this is fully simplified.
        // tsp -> tbsp -> cup -> gal -> L -> m^3
        //
        //         1 tbsp    1 cup     1 gal   3.785 L
        // 1 tsp * ------ * ------- * ------ * -------
        //         3 tsp    16 tbsp   16 cup     gal
        unitEq(
            assert,
            new KAS.Unit("tsp"),
            new KAS.Mul(
                new KAS.Rational(1, 3),
                new KAS.Rational(1, 16),
                new KAS.Rational(1, 16),
                new KAS.Float(3.785),
                new KAS.Unit("L")
            ),
            "tsp reduces"
        );

        assert.ok(
            !KAS.compare(
                new KAS.Mul(new KAS.Int(50), new KAS.Unit("m")),
                new KAS.Int(50)
            ).equal,
            "50 m != 50"
        );

        parseNeq(assert, "50 m", "50 A", "50 m != 50 A");
        parseEq(assert, "5000 mA", "5 A", "5000 mA = 5 A");
        parseNeq(assert, "5 mA", "5 A", "5 mA != 5 A");

        parseNeq(assert, "9.8 kg m / s^2", "9.8 J", "9.8 kg m / s^2 != 9.8 J");
        parseEq(assert, "9.8 kg m / s^2", "9.8 J/m", "9.8 kg m / s^2 = 9.8 J/m");

        assert.ok(!formEq("mA", "A"), "mA !== A")
        assert.ok(!formEq("g", "kg"), "g !== kg");
        assert.ok(!formEq("kg m / s^2", "N"), "kg m / s^2 !== N");
        assert.ok(!formEq("m / s^2", "N / kg"), "m / s^2 !== N / kg");

        assert.ok(formEq("A", "A"), "A === A");
        assert.ok(formEq("kg", "kg"), "kg = kg");
        assert.ok(formEq("kg m / s^2", "m kg / s^2"), "kg m / s^2 === m kg / s^2");
        assert.ok(formEq("m / s^2", "m / s^2"), "m / s^2 === m / s^2");

        // btu doesn't allow si prefixes
        assert.throws(new KAS.Unit("mBTU"), "mBTU throws");

        solveUnitVariable(
            assert,
            "2.5 gal", "cup", new KAS.Int(40)
        );

        //         1 tbsp    1 cup     1 gal    3785 L    1 m^3    ( 100 cm ) 3
        // 1 tsp * ------ * ------- * ------ * -------- * ------ * (--------)
        //         3 tsp    16 tbsp   16 cup   1000 gal   1000 L   (    m   )
        solveUnitVariable(
            assert,
            "1 tsp", "cm^3", new KAS.Rational(3785, 768)
        );

        solveUnitVariable(
            assert,
            "1 dozen qt", "gal", new KAS.Int(3)
        );

        solveUnitVariable(
            assert,
            "1 day", "sec", new KAS.Int(60*60*24)
        );

        solveUnitVariable(
            assert,
            "5 kg m / s^2", "N", new KAS.Int(5)
        );

        // This was originally broken due to a scientific notation parsing
        // problem. Leaving it around because it doesn't hurt anything.
        solveUnitVariable(
            assert,
            "5 x 10^5 N", "lb", new KAS.Int(112404)
        );

        parseMagnitude(assert, "5 x 10^5 N", 500000);
        parseMagnitude(assert, "1.23456 x 10^5 N", 123456);
        parseMagnitude(assert, "3.14 x 10^-2 N", 0.0314);
    });

    QUnit.module("isSimplified");

    var isSimplified = function(assert, input, expectedResult, options) {
        if (expectedResult === undefined) expectedResult = true;
        var message = input + (expectedResult ? " is " : " is NOT ") + "simplified";
        assert.ok(parse(input, options).isSimplified() === expectedResult, message);
    };

    QUnit.test("isSimplified (addition/subtraction)", function(assert) {
        isSimplified(assert, "a+b+c");
        isSimplified(assert, "a-b-c");
        isSimplified(assert, "a+b+c+c", false);
        isSimplified(assert, "a-b-c-d-d+d", false);
        isSimplified(assert, "x");
        isSimplified(assert, "x+0", false);
    });

    QUnit.test("isSimplified (multiplication/division/negation)", function(assert) {
        isSimplified(assert, "1/2");
        isSimplified(assert, "2/1", false);
        isSimplified(assert, "(2x)/(5x)", false);
        isSimplified(assert, "-x");
        isSimplified(assert, "-1*x");
        isSimplified(assert, "--x", false);
        isSimplified(assert, "x/1", false);
        isSimplified(assert, "x/y");
        isSimplified(assert, "xy/z");
        isSimplified(assert, "-3x");
        isSimplified(assert, "-x*3");
        isSimplified(assert, "-x*3*y");
        isSimplified(assert, "(x+1)/(2(x+1))", false);
    });

    QUnit.test("isSimplified (exponentiation)", function(assert) {
        isSimplified(assert, "x^-1");
        isSimplified(assert, "1/x");
        isSimplified(assert, "1/x^-1", false);
    });

    QUnit.test("isSimplified (logarithms)", function(assert) {
        isSimplified(assert, "ln(x)");
        isSimplified(assert, "ln(x+y)");

        // Will only expand logarithms if leads to a simpler expression
        // TODO(alex): Combine all simplify(assert, ) and isSimplified(assert, ) tests!
        isSimplified(assert, "ln(x/y)");
        isSimplified(assert, "ln(x/y)+ln(y)", false);
    });

    QUnit.test("isSimplified (equations)", function(assert) {
        isSimplified(assert, "x=10");
        isSimplified(assert, "x=-10");
        isSimplified(assert, "x=10y");
        isSimplified(assert, "x=-10y");
        isSimplified(assert, "x=10+y");
        isSimplified(assert, "x=-10+y");

        isSimplified(assert, "f(2x) = 10", true, {functions: ["f"]});
        isSimplified(assert, "f(x+x) = 10", false, {functions: ["f"]});
    });

    QUnit.test("isSimplified (equalities)", function(assert) {
        isSimplified(assert, "y=x");
        isSimplified(assert, "y=x^2");
        isSimplified(assert, "y=x*x", false);

        isSimplified(assert, "y=x^2+1");
        isSimplified(assert, "xy=x^2+1");
        isSimplified(assert, "y+1=x^2+1", false);

        isSimplified(assert, "xy=x^2", false);
        isSimplified(assert, "x^2y=x^3", false);
        isSimplified(assert, "alnx=blnx+clnx", false)

        isSimplified(assert, "xy=0");
        isSimplified(assert, "2xy=0", false);
        isSimplified(assert, "xy/z=0");
    });

    QUnit.test("isSimplified (inequalities)", function(assert) {
        isSimplified(assert, "y<x");
        isSimplified(assert, "y<x^2");
        isSimplified(assert, "y<x*x", false);

        isSimplified(assert, "y<x^2+1");
        isSimplified(assert, "xy<x^2+1");
        isSimplified(assert, "y+1<x^2+1", false);

        isSimplified(assert, "xy<x^2"); // x might be negative
        isSimplified(assert, "x^2y<x^3", false);
        isSimplified(assert, "alnx<blnx+clnx"); // lnx might be negative

        isSimplified(assert, "xy<0");
        isSimplified(assert, "2xy<0", false);
        isSimplified(assert, "xy/z<0");
    });

    QUnit.test("isSimplified (rational expressions)", function(assert) {
        isSimplified(assert, "3/4 x");
        isSimplified(assert, "3/(4x)");
        isSimplified(assert, "3/4 1/x");

        isSimplified(assert, "(x+1)/(x+2)");
        isSimplified(assert, "(x+1)/(2x+2)", false);
        isSimplified(assert, "(2x+2)/(x+1)", false);

        isSimplified(assert, "xy+2y=x+1");
        isSimplified(assert, "y=(x+1)/(x+2)");
        isSimplified(assert, "y/(x+1)=1/(x+2)");

        // TODO(alex): Combine all isSimplified(assert, ) and simplify(assert, ) tests!
        isSimplified(assert, "y=(x+1)/(2x+2)", false);
        isSimplified(assert, "y=1/2");

        isSimplified(assert, "y=(2x+2)/(x+1)", false);
        isSimplified(assert, "y=2");

        // same denominators (adding_and_subtracting_rational_expressions_1.5)
        isSimplified(assert, "(15np-25mp)/(15p^2-5p)+(20mp+10p^2)/(15p^2-5p)", false);
        isSimplified(assert, "(3n-m+2p)/(3p-1)");

        isSimplified(assert, "5yx/(2x^2+4yx)-(2x^2-6yx)/(2x^2+4yx)", false);
        isSimplified(assert, "(11y-2x)/(2x+4y)");

        isSimplified(assert, "(25m^2-20pm)/(5pm+5m)-20m^2/(5pm+5m)", false);
        isSimplified(assert, "(m-4p)/(p+1)");

        // pathological examples
        isSimplified(assert, "  (a + b)/(2c+2d)");
        isSimplified(assert, "  (3a+3b)/(2c+2d)");
        isSimplified(assert, "  (2a+2b)/( c+ d)");
        isSimplified(assert, "  (2a+2b)/(3c+3d)");
        isSimplified(assert, "  (2a+2b)/(4c+4d)", false);
        isSimplified(assert, "  (4a+4b)/(2c+2d)", false);
        isSimplified(assert, "y=(a + b)/(2c+2d)");
        isSimplified(assert, "y=(3a+3b)/(2c+2d)");
        isSimplified(assert, "y=(2a+2b)/( c+ d)");
        isSimplified(assert, "y=(2a+2b)/(3c+3d)");
        isSimplified(assert, "y=(2a+2b)/(4c+4d)", false);
        isSimplified(assert, "y=(4a+4b)/(2c+2d)", false);
    });

    var hasConsts = function(assert, input, expectedConsts, options) {
        assert.deepEqual(parse(input, options).getConsts(), expectedConsts);
    };

    QUnit.test("getConsts", function(assert) {
        hasConsts(assert, "4", []);
        hasConsts(assert, "4x", []);
        hasConsts(assert, "4pi", ["pi"]);
        hasConsts(assert, "4e", ["e"]);
        hasConsts(assert, "4pi+e", ["e", "pi"]);
        hasConsts(assert, "4pi+pi", ["pi"]);
        hasConsts(assert, "4cos(pi)", ["pi"]);
        hasConsts(assert, "4cos(xpi)", ["pi"]);
        hasConsts(assert, "(4x)/(2pi)", ["pi"]);
        hasConsts(assert, "4sec(x)", []);
    });
})(KAS);
</script>

</body>
</html>
